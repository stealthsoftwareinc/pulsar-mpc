//
// Copyright (C) 2021 Stealth Software Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person
// obtaining a copy of this software and associated documentation
// files (the "Software"), to deal in the Software without
// restriction, including without limitation the rights to use,
// copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the
// Software is furnished to do so, subject to the following
// conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
// OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
// WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
// OTHER DEALINGS IN THE SOFTWARE.
//
//
// Description: Basic enums, struct, and functions on them that are useful for
// creating and processing circuits.
//

#ifndef CIRCUIT_UTILS_H
#define CIRCUIT_UTILS_H

#include "GenericUtils/mutex.h"  // For Mutex.
#include "LoggingUtils/logging_utils.h"  // For LOG_FATAL.
#include "TestUtils/timer_utils.h"  // For SleepTimer.

#include <memory>  // For unique_ptr.
#include <string>
#include <tuple>  // For pair.
#include <vector>

namespace crypto {
namespace multiparty_computation {

// We will use GateIndexDataType to store the gate index (we opt for this over
// just using uint64_t for memory minimization, in case we later want to
// change the number of bytes (larger or smaller) we need to express gate index.
// For uint32_t, we can support circuits of size at most 2^32 = ~4 Billion gates.
typedef uint32_t GateIndexDataType;

// Structure allowing 1-2 OT. This represents the Server's private random bits
// (slices), with Client knowing exactly one value (Server doesn't know which).
template<typename value_t>
using OTPair = std::pair<value_t, value_t>;

// Holds Client's 2-pairs of (selection bit (slice) b, secret (slice) s_b)
// that will be used to first create, and then later select/unobfuscate,
// the 1-of-4 entries of a truth table (representing the output of one gate).
// NOTE: For Format 1 (i.e. if value_t is 'slice' below), each
// <selection slice b, secret slice s_b> pair is actually
// (bits_per_slice) pairs of (selection bit b_i, secret_b_i); i.e. we'll
// treat each slice as its binary representation.
template<typename value_t>
using SelectionBitAndValuePair = std::pair<OTPair<value_t>, OTPair<value_t>>;

// Holds the 4 random bits (slices) that will be used by the Server to
// obfuscate the truth table (the Client will know 1-of-4 of these).
template<typename value_t>
using TruthTableMask = std::pair<OTPair<value_t>, OTPair<value_t>>;

// A 2x2 matrix of bit (slices). Motivation: Holds the 2x2 obfuscated truth table
// generated by the Server for a 1-4 OT with the Client.
template<typename value_t>
using ObfuscatedTruthTable = std::pair<OTPair<value_t>, OTPair<value_t>>;

// Specifies the recipient of a given output value.
struct OutputRecipient {
  bool all_;
  bool none_;
  std::set<int> to_;

  OutputRecipient() {
    all_ = true;
    none_ = false;
  }
  explicit OutputRecipient(const int to) {
    all_ = false;
    none_ = false;
    to_.insert(to);
  }
  explicit OutputRecipient(const std::set<int>& to) {
    all_ = false;
    none_ = false;
    to_ = to;
  }
  OutputRecipient(const bool all, const bool none) {
    all_ = all;
    none_ = none;
  }
};

// Holds fields that can identify a Party; used by the self_party_ and
// other_party_ member variables.
struct PartyIdentifier {
  std::string name_;
  int id_;

  PartyIdentifier() {
    name_ = "";
    id_ = -1;
  }

  std::string Print() const {
    std::string to_return = "";
    if (!name_.empty() && id_ != -1) {
      to_return = name_ + "(" + std::to_string(id_) + ")";
    } else if (!name_.empty()) {
      to_return = name_;
    } else if (id_ != -1) {
      to_return = std::to_string(id_);
    }
    return to_return;
  }
};

// This structure represents a Queue (and so supports the standard FIFO push and
// pop operations), but it is intended to support concurrency in a specific
// setting, namely: there are at most two threads accessing the structure, with
// one thread doing the writing (pushing) and one thread doing the reading
// (popping). The queue is implemented using a fixed-size vector, where new
// elements can be pushed to the front of the vector (after wrapping around) if
// the reading thread has already popped them.
template<typename value_t>
struct ReadWriteQueue {
public:
  ReadWriteQueue() {
    max_size_ = -1;
    InitializeMutex(&mutex_);
    Reset();
  }
  explicit ReadWriteQueue(const int64_t size) : ReadWriteQueue() {
    max_size_ = size;
    queue_.reserve(size);
  }

  void Reset() {
    num_pushed_ = 0;
    num_popped_ = 0;
    push_index_ = 0;
    pop_index_ = 0;
    queue_.clear();
  }

  // Queue-specific operations.
  bool Push(const value_t& value) { return Push(false, value); }
  bool Pop(value_t* value) { return Pop(false, value); }
  bool PushOrSleep(const value_t& value, test_utils::SleepTimer* timer) {
    return PushOrSleep(false, value, timer);
  }
  bool PopOrSleep(value_t* value, test_utils::SleepTimer* timer) {
    return PopOrSleep(false, value, timer);
  }
  // Same as above, with mutex guards (in case Push()/Pop() may be called by
  // separate threads.
  bool SafePush(const value_t& value) { return Push(true, value); }
  bool SafePop(value_t* value) { return Pop(true, value); }
  bool SafePushOrSleep(const value_t& value, test_utils::SleepTimer* timer) {
    return PushOrSleep(true, value, timer);
  }
  bool SafePopOrSleep(value_t* value, test_utils::SleepTimer* timer) {
    return PopOrSleep(true, value, timer);
  }

  // Override common vector operations.
  bool empty() const { return num_pushed_ == num_popped_; }
  size_t size() const { return (num_pushed_ - num_popped_); }
  int64_t capacity() const { return max_size_; }
  void reserve(size_t value) {
    if (value == 0) return;
    queue_.reserve(value);
    // NOTE: We don't simply write 'max_size_ < value' because the comparison
    // below will force max_size to have same type as 'value', and hence if
    // max_size is negative but value has unsigned type, the comparison will be invalid.
    if (max_size_ < 0 || (size_t) max_size_ < value) {
      // The indexing of push_index_ and pop_index_ are with respect to the original
      // max_size_. This is fine so long as push_index_ is ahead of pop_index_ (i.e.
      // it hasn't 'wrapped around'), but this will cause weirdness otherwise.
      // Thus, in this case, we must copy buffer and start over.
      mutex_->GrabLock();
      if (push_index_ == pop_index_ && push_index_ == 0) {
        push_index_ = num_pushed_ - num_popped_;
      } else if (push_index_ == pop_index_ && num_pushed_ != num_popped_) {
        std::vector<value_t> temp;
        temp.reserve(value);
        while (num_pushed_ != num_popped_) {
          temp.push_back(value_t());
          if (!Pop(&temp.back())) LOG_FATAL("Unable to reserve.");
        }
        // The 'Pop()' done in the while loop above wasn't real. Update counter.
        num_popped_ -= temp.size();
        push_index_ = temp.size();
        pop_index_ = 0;
        queue_.swap(temp);
        queue_.reserve(value);
      } else if (push_index_ < pop_index_) {
        std::vector<value_t> temp;
        temp.reserve(value);
        while (push_index_ != pop_index_) {
          temp.push_back(value_t());
          if (!Pop(&temp.back())) LOG_FATAL("Unable to reserve.");
        }
        // The 'Pop()' done in the while loop above wasn't real. Update counter.
        num_popped_ -= temp.size();
        push_index_ = temp.size();
        pop_index_ = 0;
        queue_.swap(temp);
        queue_.reserve(value);
      }
      max_size_ = value;
      mutex_->ReleaseLock();
    }
  }
  void clear() { Reset(); }
  // NOTE: We intentionally don't support some vector operations, as they
  // have the danger of being misused/interpretted since we're actually
  // implementing a queue here; namely: resize() and pop_back().

  // Overload [] to access the i^th element, where 0^th element is 'pop_index_'.
  const value_t& operator[](const int64_t& index) const {
    if (index < 0 || num_popped_ > num_pushed_ || pop_index_ + index < 0 ||
        (uint64_t) index >= num_pushed_ - num_popped_ ||
        (uint64_t) index >= queue_.size()) {
      LOG_FATAL("Seg Fault.");
    }
    if ((uint64_t) (pop_index_ + index) >= queue_.size()) {
      return queue_[pop_index_ + index - queue_.size()];
    } else {
      return queue_[pop_index_ + index];
    }
  }
  value_t& operator[](const int64_t& index) {
    if (index < 0 || num_popped_ > num_pushed_ || pop_index_ + index < 0 ||
        (uint64_t) index >= num_pushed_ - num_popped_ ||
        (uint64_t) index >= queue_.size()) {
      LOG_FATAL("Seg Fault.");
    }
    if ((uint64_t) (pop_index_ + index) >= queue_.size()) {
      return queue_[pop_index_ + index - queue_.size()];
    } else {
      return queue_[pop_index_ + index];
    }
  }

  // Access to member-fields
  uint64_t NumPushed() const { return num_pushed_; }
  uint64_t NumPopped() const { return num_popped_; }

private:
  int64_t max_size_;
  uint64_t num_pushed_;
  uint64_t num_popped_;
  int64_t push_index_;
  int64_t pop_index_;
  std::vector<value_t> queue_;
  std::unique_ptr<Mutex> mutex_;

  // Internal calls to Push/Pop, which include specification if mutex_ should be used.
  bool Push(const bool safe, const value_t& value);
  bool Pop(const bool safe, value_t* value);
  bool PushOrSleep(
      const bool safe, const value_t& value, test_utils::SleepTimer* timer);
  bool PopOrSleep(
      const bool safe, value_t* value, test_utils::SleepTimer* timer);
};

}  // namespace multiparty_computation
}  // namespace crypto
#endif
