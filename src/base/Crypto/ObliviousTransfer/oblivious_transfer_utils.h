//
// Copyright (C) 2021 Stealth Software Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person
// obtaining a copy of this software and associated documentation
// files (the "Software"), to deal in the Software without
// restriction, including without limitation the rights to use,
// copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the
// Software is furnished to do so, subject to the following
// conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
// OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
// WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
// OTHER DEALINGS IN THE SOFTWARE.
//
// Description:
//   Various implementations of OT Protocols.
//
// Discussion:
//  A) Currently, there are two stand-alone OT protocols
//  implemented. all others require an underlying (black-box) OT
//  protocol that they extend.
//    i) Paillier
//      a) Client picks Paillier params (secret key, public key).
//      b) Client sends paillier public params to Server.
//      c) Server sends E(s_0 + b * (s_1 - s_0)) = s_1 * E(b) + s_0 * E(1-b) to Client.
//      d) Client decrypts to get s_b.
//
//    ii) Diffie-Hellman (see Chou-Orlandi description at:
//          https://eprint.iacr.org/2015/267.pdf):
//        This is a generic protocol that can work with a variety of
//        cryptographically secure groups. Currently, we support this
//        protocol for two specific groups:
//          I) Diffie-Hellman Group #14:
//               https://tools.ietf.org/html/rfc3526#section-3
//         II) Edwards Curve Group ED25519:
//               See references within https://eprint.iacr.org/2015/267.pdf
//             Namely, the EC has properties:
//               - Field Modulus: 2^255 - 19
//               - Group Size: 8 * l, where l is prime:
//                   l = 2^252 + 27742317777372353535851937790883648493
//               - Subgroup of order l (see above) is generated by element:
//                   (x, y),
//                 where y = 4/5, and x is the corresponding "positive" root.
//               - E.C. parameter 'a' is -1
//               - E.C. parameter 'd' is -121665/121666
//               - The actual group used is the cyclic subgroup mentioned above.
//        Independent of underlying group, the Diffie-Hellman OT proceeds as:
//      a) Let 'g' denote a generator for the group (g = 2 works in case (I) above,
//         and g for (II) was described above). Let 'p' denote the prime order
//         of this group.
//      b) Server picks random a <- Z_p, and sends Client: A := g^a
//      c) For i = 1..#Secrets, Client picks b_i <- Z_p. Letting c_i denote
//         Client's selection bit, Client will send Server B_i, where:
//           B_i :=   g^b_i, if c_i = 0
//           B_i := A*g^b_i, if c_i = 1
//      d) Additionally, Client computes keys k_i: H(A^b_i), where A was what
//         the Client received from Server in step (b), and H is a random oracle.
//      e) For each i, Server computes two keys:
//            k0_i: B^a
//            k1_i: (B/A)^a
//         Server hashes these two values (via Random Oracle), creating two
//         encryption keys, and then sends the two messages {M0_i, M1_i},
//         encrypted under these keys, back to Client.
//      f) Client can decrypt exactly one of these messages (namely, M(c_i)_i),
//         using his key from step (d).
//      NOTE: We need a way to "encode" group elements, so that:
//         1) Client and Server can send group elements to each other
//         2) Client and Server can apply R.O. "H" to group elements
//      Thus, an encoding/decoding must be specified:
//         E: G -> {0, 1}^|G|
//         D: {0, 1}^|G| -> G
//      Additionally, Diffie-Hellman OT requires specification of an encryption
//      scheme Enc and random oracle H:
//        Enc: {0, 1}^lambda -> {0, 1}^lambda
//        H:   {0, 1}^|G| -> {0, 1}^lambda
//      We implement these as:
//        Enc: AES-128
//        H: SHA256 (take only the leading 128 bits)
//
//  B) Currently, there are two kinds of OT extension protocols:
//      i)   PRG:  OT_m   -> OT_poly(m)
//      ii)  IKNP: OT^k_m -> OT^m_l; where k is security parameter, m and l arbitrary
//           Based on IKNP paper: "Extending Oblivious Transfers Efficiently", Fig 1, 2.
//           saved in Stealth/Brandeis/Enterprise_SRI/Papers/IKNP_OT_Extension.pdf
//      iii*) IKOS: OT^m_l -> OT^n_1, where m, l ~ sqrt{n}.
//           Based on IKOS paper "Cryptography with Constant Computation Overhead",
//           saved in Stealth/Brandeis/Enterprise_SRI/Papers/IKOS_two_party_computation.pdf
//           See thorough description in google doc:
//           https://docs.google.com/document/d/1smh_lsjsUVEAL51NvHXis-lkJ2v-fk23C_NnRk5GG8U/
//     If these are used together, this is how parameters look:
//           OT^n_1 <--IKOS-- OT^m_l <--IKNP-- OT^k_m <--PRG-- OT^k_m' <--Pailler-- OT^k_lambda,
//     where m, l ~ sqrt{n} depend on the IKOS DRE used (see comment below),
//     k is the security parameter for IKOS, poly(m') ~ m, and lambda is the number of
//     security bits for Paillier (currently, lambda = 2048, as per kPaillierCryptosystemBits
//     in paillier.h).
//     * Comment: The IKOS08 paper suggests candidate PRGs with long stretch in NC^0, such as
//     the Mossel-Shpilka-Trevisan (MST) epsilon-biased generator. However, it is not known
//     if such PRGs exist, and the candidate MST generator most likely does not
//     provide sufficient security guarantees for most reasonable parameter sizes.
//     Thus, IKOS08 style OT extension is no longer supported in this repo.
//     New alternatives such as Silent OT and Pseudorandom Correlation Generators would be
//     a viable drop-in replacement here, both of which were invented subsequent to the
//     completion of this project, though we are independently investigating them.
//
//  C) Regarding running-time of each OT protocol:
//     NOTE 1: For a lengthy discussion on running time of all the OT protocols,
//             see output comments at the end of oblivious_transfer_utils_test.cpp.
//     NOTE 2: The times below ignore the time that the underlying OT protocol takes):
//     NOTE 3: Summary:
//               IKNP + PRG + Paillier:  (1.21 * n / 2^16) + (6 * n * l / 2^30) + 1.45
//             The time for IKNP + PRG + Paillier comes from:
//               IKNP:      (1.16 * n / 2^16) + (6 * n * l / 2^30)s
//               PRG:       (6.5 * 128 * n / 2^30)s
//               Paillier:  1.45s
//       i)  Paillier OT^k1_k2:
//              - 5.22s, for single thread and k1 = 128, k2 = 2048
//              - 2.66s, for two threads and k1 = 128, k2 = 2048
//              - 1.33s, for > 4 threads and k1 = 128, k2 = 2048
//           Note 1: By construction, Paillier OT works for k2-bit secrets, where k2
//           is the security parameter for the Paillier cryptosystem (currently 2048).
//           Note 2: Since usage of Paillier is typically through IKNP, and since
//           the latter requires k1 invokations of its underlying OT for some
//           security parameter k1, we present time benchmark for Paillier OT^k1.
//           Note 3: The time bottlenecks are as follows:
//             - 4/9 (0.67s): Computing randomness r^n (mod n^2) for Receiver's
//               ciphertexts {E(0), E(1)}
//             - 2/9 (0.33s): Computing randomness r^n (mod n^2) for Sender to
//               rerandomize the ciphertext E(s_b * 0 + s_~b * 1)
//             - 1/3 (0.50s): Computing c^lambda (mod n^2) for Receiver to decrypt
//      ii) PRG OT^k_m -> OT^k_l, where l = poly(m):
//             - OT^k_m + (6 * k * l / 2^30) seconds, for single thread and m = 512
//          NOTE0: If underlying OT^k_m is Paillier, the time for underlying
//                 OT^k_m is roughly (1.5 * k / 2^7) = 6 * k / 2^9seconds, so
//                 the overall time of PRG OT^k_m is:
//                   (6 * k / 2^9) + (6 * k * l / 2^30) seconds, which is roughly
//                   (6 * k * l / 2^30)s if l >> 2^21
//          NOTE1: The current PRG we use (which is basically AES-128) is from
//                   PRG: {0, 1}^128 -> {0, 1}^poly(128);
//                 i.e. the number of bits in the secrets ('m') is a security
//                 parameter (128), and l = poly(m) is polynomial in the sec. param
//          NOTE2: The running time is mostly from the 3 * k underlying calls to
//                 ApplyPrg(): 2 * k by the Server, k by the Client. See the
//                 time-benchmarks of ApplyPrg: 3 * k such calls take
//                 ~ (3 * k * 1.15 * l / 2^30) seconds, which is ~60% of the above formula.
//                 The other 40% is from cost of communicating bytes across
//                 network, doing XOR's, etc.
//     iii) IKNP OT^k_m -> OT^m_l:
//            - OT^k_m + (1.16 * m / 2^16) + (6 * m * l / 2^30) seconds,
//              for a single thread and security param k = 128
//          NOTE:  The running time is mostly from the 3 * m underlying calls to
//                 ROEvaluate() (2 * m by Server, m by Client), this accounts for
//                 (0.16 * m / 2^16 + 3.5 * m * l / 2^30) seconds, which is
//                 roughly 60% of the overall cost (again, the other 40% is
//                 from communicating bytes, XOR's, etc.).
//  d) The optimal combination of OT's to use (in terms of minimizing running time) is:
//       IKNP + PRG + BaseOT,
//     where BaseOT is one of { Diffie-Hellman OT, Paillier },
//     where Diffie-Hellman OT can be based on either DH or EdwardsCurve.
//     More generally, denoting paramters:
//       (n, l) = (num secrets, num bits per secret):
//     then running OT via (IKNP + PRG + BaseOT) has the following properties:
//       i) OT^sqrt{n}_sqrt{n} <- OT^k_sqrt{n} <- OT^k_k' <- OT_k'
//          where n is arbitrary, k = 128 is the security parameter for the
//          underlying RO in IKNP, k' = 128 is the Paillier security parameter;
//          and the first arrow is IKNP, the next is PRG, and the last is
//          k-invokations of BaseOT (e.g. Paillier OT_k')
//      ii) With k = 128, k' = 512, (IKNP + PRG + Paillier) takes (for a single thread):
//               (1.21 * n / 2^16) + (6 * n * l / 2^30) + 1.45
//          which comes from:
//            37.12 * sqrt{n} / 2^21 + 5 * n / 2^30: For IKNP_OT^sqrt{n}_sqrt{n}
//            1.5   * sqrt{n} / 2^21:                For PRG OT^128_sqrt{n}
//            1.45:                                  For Paillier OT^128_512
//          More precisely, running time for IKNP (w/ parameters n,l):
//               (3.25 * n * l / 2^29) + 1.5 seconds, if l >> 4,000
//               (1.67 * n / 2^19)     + 1.5 seconds, if l << 4,000
//  e) Moving forward, reducing overall time for OT can be achieved by:
//       i) Don't reduce the time, but use Beaver's offline trick, so that all
//          the OT's are computed ahead of time, and then the actual OT's are
//          just XOR's of the precomputed (random) OT bits and the actual ones
//      ii) Use multiple threads. This is already implemented, and will take
//          advantage of however many cores are available on the running machine
//     iii) Chain together more extension protocols, so that the OT^a_b parameters
//          'a' and 'b' are reduced for each step
//      iv) Reduce the time of the base OT:
//            A) Use a different base OT than Paillier (e.g. eprint.iacr.org/2015/267.pdf)
//            B) Pre-compute randomness r^n (mod n^2)
//            C) Use a different libarary than libtommath for computation (e.g. mpir or GMP)
//               UPDATE: DONE. Default uses GMP now.
//            D) Use smaller security parameter (< 128) for Paillier cryptosystem
//            E) Compute r^n (mod n^2) once, then for all other randomness, compute
//               (r^n)^a (mod n^2) for "small" 'a'.
//       v) Reduce the time of PRG OT:
//            A) Use a different underlying PRG (currently we use Aes128 PRG)
//      vi) Reduce the time of IKNP OT:
//            A) Use a different RO
//            B) Since the RO uses underlying PRG, we can use the same RO, but
//               based on a different underlying PRG
//     vii) Find a valid PRG to implement IKOS OT.
#ifndef OBLIVIOUS_TRANSFER_UTILS_H
#define OBLIVIOUS_TRANSFER_UTILS_H

#include "Crypto/Encryption/aes_utils.h"
#include "Crypto/Encryption/paillier.h"
#include "Crypto/RandomNumberGeneration/prg_utils.h"
#include "Crypto/RandomNumberGeneration/random_oracle_utils.h"
#include "MathUtils/AbstractAlgebra/group.h"
#include "MathUtils/large_int.h"
#include "Networking/socket.h"
#include "global_utils.h"

#include <memory>  // For unique_ptr
#include <string>
#include <vector>

namespace crypto {

// A list of all OT protocols implemented here.
enum class OTProtocol {
  NONE,

  // Base OT (does not rely on an underlying OT protocol).
  PAILLIER,
  DIFFIE_HELLMAN,

  // The following will extend an underlying OT protocol.
  PRG_EXTENSION,
  IKNP_EXTENSION,
};

enum class OTProtocolCombo {
  UNKNOWN,
  PAILLIER,
  DIFFIE_HELLMAN,

  // The following are more complex combinations of the basic OTProtocol types.
  // They can be used as input to Set[Server | Client]OTParams().
  PRG_FROM_PAILLIER,
  IKNP_FROM_PAILLIER,
  PRG_FROM_DIFFIE_HELLMAN,
  IKNP_FROM_DIFFIE_HELLMAN,

  IKNP_FROM_PRG_FROM_PAILLIER,
  IKNP_FROM_PRG_FROM_DIFFIE_HELLMAN,
};

// Holds the Client's selection bit b and the Server's secret s_b that
// were used/obtained from a single 1-2 OT.
// NOTE: I wanted the type of b_ and s_b_ to be general; e.g. to support 'b'
// being a bit, slice, etc., and secret s_b being a bit, slice, LargeInt, string,
// etc. One option for achieving this would be to template this struct (perhaps
// a double template, with one type for b_ and one for s_b_); I instead achieve
// the generality using a vector<unsigned char> that will represent the desired
// type, as it was easier to implement.
struct ClientSelectionBitAndSecret {
  // Client's selection bit b.
  bool b_;
  // Byte-representation of Server's secret s_b. This vector will have length
  // 1 if Server's secrets are a single bit; otherwise it has length equal to the
  // number of bytes in the Server's secrets.
  // NOTE: Ideally, we'd use a vector<bit> (e.g. vector<bool>) for this data
  // structure. But the minimum size type of C++ is a byte, and the vector<bool>
  // is handled specially (and in particular, does not behave the way that the
  // ordinary vector<> behaves). Thus, we require the user to cast the secret
  // into a byte (unsigned char) stream. There are then two options for
  // representing an n-bit secret:
  //   a) Use n-bytes
  //   b) Pack the n-bits into (n / 8) bytes
  // Option (a) is more straightforward in terms of implementation, while (b) is
  // more efficient (requires less storage/memory, and also less communication).
  // Notice though that there is nothing in oblivious_transfer_utils that
  // requires distinguishing between (a) vs. (b); that is, the caller can
  // handle the outputs {s_b_} of the OT protocol in a manner (in terms of (a)
  // vs. (b)) consistent with how the secrets s0_ and s1_ were constructed.
  std::vector<unsigned char> s_b_;

  ClientSelectionBitAndSecret() { b_ = false; }

  ClientSelectionBitAndSecret(const bool selection_bit) { b_ = selection_bit; }
};

struct ServerSecretPair {
  // Byte-representation of Server's secret s_0. This vector has length equal to
  // the number of bytes in s0_ (typically just '1', but sometimes e.g. 'slice').
  // NOTE: See NOTE above ClientSelectionBitAndSecret.s_b_ as to why we use bytes
  // instead of bits for this. In case s_0 is a bit, we (arbitrarily) declare
  // the last bit of byte s0_[0] to represent s_0.
  std::vector<unsigned char> s0_;
  // Byte-representation of Server's secret s_1. This vector has length equal to
  // the number of bytes in s1_ (typically just '1', but sometimes e.g. 'slice').
  // NOTE: See NOTE above ClientSelectionBitAndSecret.s_b_ as to why we use bytes
  // instead of bits for this. In case s_1 is a bit, we (arbitrarily) declare
  // the last bit of byte s1_[0] to represent s_1.
  std::vector<unsigned char> s1_;

  ServerSecretPair() {}

  ServerSecretPair(const int num_bytes) {
    s0_.resize(num_bytes, 0);
    s1_.resize(num_bytes, 0);
  }

  ServerSecretPair(
      const std::vector<unsigned char>& s0,
      const std::vector<unsigned char>& s1) {
    s0_ = s0;
    s1_ = s1;
  }
};

// Fields used to specify how to setup [Client | Server]OTParams via the call to
// Set[Client | Server]OTParams
struct OTParamsSetup {
  // Mandatory fields.
  OTProtocolCombo type_;
  uint64_t num_secrets_;
  uint64_t num_bytes_per_secret_;
  // Parallelization. Specify '-1' to let the program determine the optimal
  // number of threads to use (based on system, i.e. number of cores available);
  // or specify a number >= 1 to hard-code the number of threads to use.
  int num_threads_;

  // Optional fields.
  // - Connection.
  networking::Socket* connection_;
  // - Selection bits (if setting up ClientOTParams).
  std::vector<ClientSelectionBitAndSecret>* selection_bits_;
  // - Secrets (if setting up ServerOTParams).
  std::vector<ServerSecretPair>* secrets_;
  // - If Paillier OT is used, you can (optionally) specify files to read
  //   in public/private key information (if not set, OT protocol will first
  //   generate these, which takes a lot of time; e.g. 16 seconds).
  std::string paillier_n_file_;
  std::string paillier_g_file_;
  std::string paillier_lambda_file_;
  std::string paillier_mu_file_;
  // - If Diffie-Hellman OT is used, the underlying group can be a DH-type
  //   group or EC. This sepecifies which.
  bool use_edwards_curve_;
  // - If Diffie-Hellman OT is used, this gives the secret exponent(s)
  //   (notation: 'a' for the Server, 'b' for the Client, in Chou-Orlandi paper).
  //   We make this a pointer to overload the fact that it is a single value
  //   for the Server, and a vector of values (vector length = number secrets)
  //   for the Client.
  //   NOTE: If DH-OT is specified, it is okay if this value is NULL (for both
  //   Client and Server). In this case, random values (in the appropriate
  //   modulus, i.e. GetEdwardCurveSubgroupSize() if 'use_edwards_curve' is true
  //   or GetDiffieHellmanGroupFourteenSize() otherwise) will be generated as
  //   part of the OTParamsSetup().
  const LargeInt* diffie_hellman_exponent_;
  // - If PRG OT is used, the following field is mandatory.
  uint64_t prg_domain_bytes_;
  // - If IKNP OT is used, the following field is mandatory.
  uint64_t iknp_ro_security_param_bytes_;

  // Basic Constructor.
  OTParamsSetup();
  // Constructor with type.
  explicit OTParamsSetup(const OTProtocolCombo type);
  OTParamsSetup(
      const OTProtocolCombo type,
      const uint64_t& num_secrets,
      const uint64_t& bytes_per_secret = 1,
      const std::string& paillier_n_file = "",
      const std::string& paillier_g_file = "",
      const std::string& paillier_lambda_file = "",
      const std::string& paillier_mu_file = "",
      const bool use_edwards_curve = false,
      // NOTE: The following copies the data being pointed to, so it's
      // okay if the memory being pointed to is destroyed immediately
      // upon return (e.g. caller has made a local (stack) variable).
      const LargeInt* diffie_hellman_exponent = nullptr,
      const uint64_t& prg_domain_bytes = 0,
      const uint64_t& iknp_sec_param_bytes = 0,
      // (At least) one of the two parameters below should be NULL.
      std::vector<ServerSecretPair>* secrets = nullptr,
      std::vector<ClientSelectionBitAndSecret>* selection_bits = nullptr,
      networking::Socket* connection = nullptr,
      const int num_threads = -1);
  // An alternate API for not specifying paillier/diffie-hellman files (for party that will
  // be playing the role of the Server for Paillier OT).
  // Note that the 'garbage_param' parameter is ignored: it is just
  // needed to be able to distinguish this constructor from the above, since
  // otherwise calls that don't set all parameters will be ambiguous.
  OTParamsSetup(
      const OTProtocolCombo type,
      const std::string& garbage_param,
      const uint64_t& num_secrets,
      const uint64_t& bytes_per_secret = 1,
      const bool use_edwards_curve = false,
      // NOTE: The following copies the data being pointed to, so it's
      // okay if the memory being pointed to is destroyed immediately
      // upon return (e.g. caller has made a local (stack) variable).
      const LargeInt* diffie_hellman_exponent = nullptr,
      const uint64_t& prg_domain_bytes = 0,
      const uint64_t& iknp_sec_param_bytes = 0,
      // (At least) one of the two parameters below should be NULL.
      std::vector<ServerSecretPair>* secrets = nullptr,
      std::vector<ClientSelectionBitAndSecret>* selection_bits = nullptr,
      networking::Socket* connection = nullptr,
      const int num_threads = -1);
};

// Generic Structures to hold [Server | Client] parameters that are part of any
// OT protocol. Specific OT Protocols will inherit from this base structure.
struct ServerOTParams {
  // The server's secret pairs.
  std::vector<ServerSecretPair>* secrets_;

  // Connection to use for communication with Client.
  std::unique_ptr<networking::Socket> connection_to_client_;

  // Number of threads to use for local computations.
  int num_threads_;

  // In case an error occured, it will be stored here.
  // NOTE: Using e.g. LOG_ERROR is not sufficient here, as the OT task
  // may be performed by a subthread instead of the main thread, and
  // then there is no guarantee the 'cout' call (which is used under-the-hood
  // of LOG_ERROR) will be completed before the subthread returns.
  std::string error_msg_;

  // The actual OT protocol to use; i.e. which instance of ServerOTParams this
  // ServerOTParams actually is.
  OTProtocol protocol_;
  // Whether this instance is being used as a black-box underlying OT-Protocol
  // for another OT-Protocol, or if this is the top-level OT Protocol.
  bool is_black_box_;

  // Whether to keep timer.
  bool is_debug_;

  ServerOTParams() {
    secrets_ = nullptr;
    connection_to_client_ = nullptr;
    num_threads_ = -1;
    error_msg_ = "";
    protocol_ = OTProtocol::NONE;
    is_black_box_ = false;
    is_debug_ = false;
  }
  ServerOTParams(const ServerOTParams& p) {
    connection_to_client_ =
        std::unique_ptr<networking::Socket>(p.connection_to_client_->clone());
    num_threads_ = p.num_threads_;
    error_msg_ = p.error_msg_;
    protocol_ = p.protocol_;
    is_black_box_ = p.is_black_box_;
    is_debug_ = p.is_debug_;
  }
  // Virtual destructor (to ensure destructors of derived classes below get called).
  virtual ~ServerOTParams() {}

  // Virtual constructor (creation)
  virtual ServerOTParams* create() const { return new ServerOTParams(); }
  // Virtual constructor (copying)
  virtual ServerOTParams* clone() const { return new ServerOTParams(*this); }
};
struct ClientOTParams {
  // The selection bit inputs {b_i} for the client, as well as the final outputs
  // {s_b_i}; the first part of each pair (selection bits b_i) are set on input,
  // the second part of each pair (final outputs {s_b_i}) is set on output.
  std::vector<ClientSelectionBitAndSecret>* selection_bits_and_output_secret_;

  // Connection to use for communication with Server.
  std::unique_ptr<networking::Socket> connection_to_server_;

  // Number of threads to use for local computations.
  int num_threads_;

  // In case an error occured, it will be stored here.
  // NOTE: Using e.g. LOG_ERROR is not sufficient here, as the OT task
  // may be performed by a subthread instead of the main thread, and
  // then there is no guarantee the 'cout' call (which is used under-the-hood
  // of LOG_ERROR) will be completed before the subthread returns.
  std::string error_msg_;

  // The actual OT protocol to use; i.e. which instance of ClientOTParams this
  // ClientOTParams actually is.
  OTProtocol protocol_;
  // Whether this instance is being used as a black-box underlying OT-Protocol
  // for another OT-Protocol, or if this is the top-level OT Protocol.
  bool is_black_box_;

  // Whether to keep timer.
  bool is_debug_;

  ClientOTParams() {
    selection_bits_and_output_secret_ = nullptr;
    connection_to_server_ = nullptr;
    num_threads_ = -1;
    error_msg_ = "";
    protocol_ = OTProtocol::NONE;
    is_black_box_ = false;
    is_debug_ = false;
  }
  ClientOTParams(const ClientOTParams& p) {
    connection_to_server_ =
        std::unique_ptr<networking::Socket>(p.connection_to_server_->clone());
    num_threads_ = p.num_threads_;
    error_msg_ = p.error_msg_;
    protocol_ = p.protocol_;
    is_black_box_ = p.is_black_box_;
    is_debug_ = p.is_debug_;
  }
  // Virtual destructor (to ensure destructors of derived classes below get called).
  virtual ~ClientOTParams() {}

  // Virtual constructor (creation)
  virtual ClientOTParams* create() const { return new ClientOTParams(); }
  // Virtual constructor (copying)
  virtual ClientOTParams* clone() const { return new ClientOTParams(*this); }
};

// Parameters required to run Paillier OT.
struct ServerPaillierOTParams : public ServerOTParams {
  encryption::PaillierPublicKey key_;

  ServerPaillierOTParams() : ServerOTParams() {}
  // Copy Constructor does not specify 'const' for the input parameter,
  // since the line 'key_ = p.key_' will fail if p is const (since the
  // underlying PaillierPublicKey Copy Constructor does not have 'const';
  // see the comments in paillier.h above the Copy Constructor).
  ServerPaillierOTParams(ServerPaillierOTParams& p) : ServerOTParams(p) {
    key_ = p.key_;
  }
  // Virtual destructor (to ensure destructors of derived classes below get called).
  virtual ~ServerPaillierOTParams() {}

  // Virtual constructor (creation)
  virtual ServerPaillierOTParams* create() const {
    return new ServerPaillierOTParams();
  }
  // Virtual constructor (copying)
  // NOTE: This function is not labelled 'const', since it relies on the non-const
  // API of the Copy Constructor above.
  virtual ServerPaillierOTParams* clone() {
    return new ServerPaillierOTParams(*this);
  }
};
struct ClientPaillierOTParams : public ClientOTParams {
  // When setting up the PaillierParams, if paillier_params_.type_ equals
  // BYTE_STRING or BIT_STRING, the paillier_params_.plaintext_size_ *must*
  // be explicitly set, or inconsistencies will result.
  encryption::PaillierParams paillier_params_;
  bool is_key_setup_;

  ClientPaillierOTParams() : ClientOTParams() {
    paillier_params_.type_ = encryption::PlaintextType::BYTE_STRING;
    is_key_setup_ = false;
  }
  // Copy Constructor does not specify 'const' for the input parameter,
  // since the line 'key_ = p.key_' will fail if p is const (since the
  // underlying PaillierParams Copy Constructor does not have 'const';
  // see the comments in paillier.h above the Copy Constructor).
  ClientPaillierOTParams(ClientPaillierOTParams& p) : ClientOTParams(p) {
    paillier_params_ = p.paillier_params_;
    is_key_setup_ = p.is_key_setup_;
  }
  // Virtual destructor (to ensure destructors of derived classes below get called).
  virtual ~ClientPaillierOTParams() {}

  // Virtual constructor (creation)
  ClientPaillierOTParams* create() const { return new ClientPaillierOTParams(); }
  // Virtual constructor (copying).
  // NOTE: This function is not labelled 'const', since it relies on the non-const
  // API of the Copy Constructor above.
  virtual ClientPaillierOTParams* clone() {
    return new ClientPaillierOTParams(*this);
  }
};
struct ServerDiffieHellmanOTParams : public ServerOTParams {
  std::unique_ptr<math_utils::GroupElement> g_;
  LargeInt a_;
  RandomOracleParams ro_params_;
  encryption::AesParams enc_params_;

  ServerDiffieHellmanOTParams() : ServerOTParams() {}
  ServerDiffieHellmanOTParams(const ServerDiffieHellmanOTParams& p) :
      ServerOTParams(p) {
    g_ = std::unique_ptr<math_utils::GroupElement>(
        CreateGroupElementCopy(*(p.g_.get())));
    a_ = p.a_;
    ro_params_ = p.ro_params_;
    enc_params_ = p.enc_params_;
  }
  // Virtual destructor (to ensure destructors of derived classes below get called).
  virtual ~ServerDiffieHellmanOTParams() {}

  // Virtual constructor (creation)
  virtual ServerDiffieHellmanOTParams* create() const {
    return new ServerDiffieHellmanOTParams();
  }
  // Virtual constructor (copying)
  virtual ServerDiffieHellmanOTParams* clone() const {
    return new ServerDiffieHellmanOTParams(*this);
  }
};
struct ClientDiffieHellmanOTParams : public ClientOTParams {
  std::unique_ptr<math_utils::GroupElement> g_;
  std::vector<LargeInt> b_;
  RandomOracleParams ro_params_;
  encryption::AesParams enc_params_;

  ClientDiffieHellmanOTParams() : ClientOTParams() {}
  ClientDiffieHellmanOTParams(const ClientDiffieHellmanOTParams& p) :
      ClientOTParams(p) {
    g_ = std::unique_ptr<math_utils::GroupElement>(
        CreateGroupElementCopy(*(p.g_.get())));
    b_ = p.b_;
    ro_params_ = p.ro_params_;
    enc_params_ = p.enc_params_;
  }
  // Virtual destructor (to ensure destructors of derived classes below get called).
  virtual ~ClientDiffieHellmanOTParams() {}

  // Virtual constructor (creation)
  ClientDiffieHellmanOTParams* create() const {
    return new ClientDiffieHellmanOTParams();
  }
  // Virtual constructor (copying).
  virtual ClientDiffieHellmanOTParams* clone() const {
    return new ClientDiffieHellmanOTParams(*this);
  }
};

// Parameters required to run PRG OT-Extension (OT^k_n from OT^k_m + PRG: m -> n)
struct ServerPrgOTExtensionParams : public ServerOTParams {
  // The underlying PRG: {0, 1}^m -> {0, 1}^n to use.
  // NOTE: The prg_.domain_bits_ should be set to the desired 'm' value (can
  // be anything, such that 'n' is poly(m)); and the prg_.range_bits_ should
  // equal 'n': the number of bits in each secret (if not set, it will be set
  // to equal the number of bits in the Server's first secret s0).
  crypto::random_number::PseudoRandomGeneratorParams prg_;

  // The underlying OT^k_m protocol to use.
  std::unique_ptr<ServerOTParams> black_box_ot_params_;

  ServerPrgOTExtensionParams() : ServerOTParams() {
    black_box_ot_params_ = nullptr;
  }
  ServerPrgOTExtensionParams(const ServerPrgOTExtensionParams& p) :
      ServerOTParams(p) {
    prg_ = p.prg_;
    black_box_ot_params_ =
        std::unique_ptr<ServerOTParams>(p.black_box_ot_params_->clone());
  }
  // Virtual destructor (to ensure destructors of derived classes below get called).
  virtual ~ServerPrgOTExtensionParams() {}

  // Virtual constructor (creation)
  virtual ServerPrgOTExtensionParams* create() const {
    return new ServerPrgOTExtensionParams();
  }
  // Virtual constructor (copying)
  virtual ServerPrgOTExtensionParams* clone() const {
    return new ServerPrgOTExtensionParams(*this);
  }
};
struct ClientPrgOTExtensionParams : public ClientOTParams {
  // The underlying PRG: {0, 1}^m -> {0, 1}^n to use.
  // NOTE: The prg_.range_bits_ should be set (and it should equal 'n', the number
  // of bits in the Server's secrets). The prg_.domain_bits_ should equal 'm' (if
  // not set, the number of bits received by the client in the underlying OT^k_m
  // protocol will be used.
  crypto::random_number::PseudoRandomGeneratorParams prg_;

  // The underlying OT^k_m protocol to use.
  std::unique_ptr<ClientOTParams> black_box_ot_params_;

  ClientPrgOTExtensionParams() : ClientOTParams() {
    black_box_ot_params_ = nullptr;
  }
  ClientPrgOTExtensionParams(const ClientPrgOTExtensionParams& p) :
      ClientOTParams(p) {
    prg_ = p.prg_;
    black_box_ot_params_ =
        std::unique_ptr<ClientOTParams>(p.black_box_ot_params_->clone());
  }
  // Virtual destructor (to ensure destructors of derived classes below get called).
  virtual ~ClientPrgOTExtensionParams() {}

  // Need to implement non-default destructor, so that the proper destructor
  // Virtual constructor (creation)
  virtual ClientPrgOTExtensionParams* create() const {
    return new ClientPrgOTExtensionParams();
  }
  // Virtual constructor (copying)
  virtual ClientPrgOTExtensionParams* clone() const {
    return new ClientPrgOTExtensionParams(*this);
  }
};

// Parameters required to run IKNP OT-Extension; see Figure 1 of
// "Extending Oblivious Transfers Efficiently"; saved in:
// Stealth/Brandeis/Enterprise_SRI/Papers/IKNP_OT_Extension.pdf
// NOTE: These params help perform OT^m_l from an underlying OT^k_m protocol, where:
//   m = num secrets = ServerIKNPOTExtensionParams.secrets_->size()
//   l = secret size = (*ServerIKNPOTExtensionParams.secrets_)[i].s[0 | 1]_.size()
//   k = ServerIKNPOTExtensionParams.num_security_param_bytes_
struct ServerIKNPOTExtensionParams : public ServerOTParams {
  // NOTE: Caller should be sure to set random_oracle_.type_ and
  // random_oracle_.prg_params_ (in particular, prg_params_.type_,
  // prg_params_.domain_bits_, and prg_params_.range_bits_; for default
  // RO (AES_ENCRYPT_PLUS_PRG), prg_params_.domain_bits_ need not be set).
  RandomOracleParams random_oracle_;
  // NOTE: The num_security_param_bytes_ is used as part of the domain of the
  // Random Oracle, which, based on current implentation, is only
  // AES_ENCRYPT_PLUS_PRG. This RO in turn relies on AES encryption, where the
  // key will have num_security_param_bytes_ bytes. Since the only currently
  // supported AES encryption is aes128 (i.e. keys have size 128-bits = 16 bytes),
  // the only value that will currently work for num_security_param_bytes_ is 16.
  uint64_t num_security_param_bytes_;

  // Since the Server actually acts as the Client w.r.t. the underlying
  // black-box OT^k_m protocol, the parameters for this OT are w.r.t. Client.
  // The fields that caller should set are:
  //   ClientOTParams: protocol_
  //   Inheriting Client*Params: Any additional fields
  std::unique_ptr<ClientOTParams> black_box_ot_params_;

  ServerIKNPOTExtensionParams() : ServerOTParams() {
    black_box_ot_params_ = nullptr;
    num_security_param_bytes_ =
        16;  // See note above declaration as to why this is 16.
  }
  ServerIKNPOTExtensionParams(const ServerIKNPOTExtensionParams& p) :
      ServerOTParams(p) {
    random_oracle_ = p.random_oracle_;
    num_security_param_bytes_ = p.num_security_param_bytes_;
    black_box_ot_params_ =
        std::unique_ptr<ClientOTParams>(p.black_box_ot_params_->clone());
  }
  // Virtual destructor (to ensure destructors of derived classes below get called).
  virtual ~ServerIKNPOTExtensionParams() {}

  // Virtual constructor (creation)
  virtual ServerIKNPOTExtensionParams* create() const {
    return new ServerIKNPOTExtensionParams();
  }
  // Virtual constructor (copying)
  virtual ServerIKNPOTExtensionParams* clone() const {
    return new ServerIKNPOTExtensionParams(*this);
  }
};
struct ClientIKNPOTExtensionParams : public ClientOTParams {
  // NOTE: Caller should be sure to set random_oracle_.type_ and
  // random_oracle_.prg_params_ (in particular, prg_params_.type_,
  // prg_params_.domain_bits_, and prg_params_.range_bits_; for default
  // RO (AES_ENCRYPT_PLUS_PRG), prg_params_.domain_bits_ need not be set).
  RandomOracleParams random_oracle_;
  uint64_t num_security_param_bytes_;

  // Since the Client actually acts as the Server w.r.t. the underlying
  // black-box OT^k_m protocol, the parameters for this OT are w.r.t. Server.
  // The fields that caller should set are:
  //   ServerOTParams: protocol_
  //   Inheriting Server*Params: Any additional fields
  std::unique_ptr<ServerOTParams> black_box_ot_params_;

  ClientIKNPOTExtensionParams() : ClientOTParams() {
    black_box_ot_params_ = nullptr;
    num_security_param_bytes_ =
        16;  // See note above declaration as to why this is 16.
  }
  ClientIKNPOTExtensionParams(const ClientIKNPOTExtensionParams& p) :
      ClientOTParams(p) {
    random_oracle_ = p.random_oracle_;
    num_security_param_bytes_ = p.num_security_param_bytes_;
    black_box_ot_params_ =
        std::unique_ptr<ServerOTParams>(p.black_box_ot_params_->clone());
  }
  // Virtual destructor (to ensure destructors of derived classes below get called).
  virtual ~ClientIKNPOTExtensionParams() {}

  // Virtual constructor (creation)
  virtual ClientIKNPOTExtensionParams* create() const {
    return new ClientIKNPOTExtensionParams();
  }
  // Virtual constructor (copying)
  virtual ClientIKNPOTExtensionParams* clone() const {
    return new ClientIKNPOTExtensionParams(*this);
  }
};

// Sets up the OT parameters, based on the fields of setup_params.
extern bool SetServerOTParams(
    const bool is_debug,
    const bool is_ot_subroutine,
    OTParamsSetup setup_params,
    ServerOTParams* params);
// Same as above, default is_debug = false.
inline bool SetServerOTParams(
    const bool is_ot_subroutine,
    OTParamsSetup setup_params,
    ServerOTParams* params) {
  return SetServerOTParams(false, is_ot_subroutine, setup_params, params);
}
extern bool SetClientOTParams(
    const bool is_debug,
    const bool is_ot_subroutine,
    OTParamsSetup setup_params,
    ClientOTParams* params);
// Same as above, default is_debug = false.
inline bool SetClientOTParams(
    const bool is_ot_subroutine,
    OTParamsSetup setup_params,
    ClientOTParams* params) {
  return SetClientOTParams(false, is_ot_subroutine, setup_params, params);
}

// DEPRECATED.
// Warning: These methods are only currently used in oblivious_transfer_utils_test.cpp.
// They should be used in actual code with care, as they only set the num_threads_
// field of the parent OTParams (so for any OT Extension, which is almost always what
// is actually used, it will only set the number of threads for the top-most protocol).
extern void SetServerOtNumThreads(const int num_threads, ServerOTParams* params);
extern void SetClientOtNumThreads(const int num_threads, ClientOTParams* params);

// TODO(PHB): Determine if it makes sense to make all of these API's public,
// or if I should just move them to the anonymous namespace, and force
// all calls through the [Server | Client]OT() API

// Perform Paillier OT as Server. This function has no output, since Server
// has no output in OT.
extern bool ServerPaillierOT(ServerPaillierOTParams* params);
// Perform Paillier OT as Client. Output is stored in
// params->selection_bits_and_output_secret_[i].s_b_.
extern bool ClientPaillierOT(ClientPaillierOTParams* params);

// Perform Diffie-Hellman OT as Server. This function has no output, since Server
// has no output in OT.
extern bool ServerDiffieHellmanOT(ServerDiffieHellmanOTParams* params);

// Perform Diffie-Hellman OT as Client. Output is stored in
// params->selection_bits_and_output_secret_[i].s_b_.
extern bool ClientDiffieHellmanOT(ClientDiffieHellmanOTParams* params);

// Perform PRG OT-Extension as Server:
// Performs OT^k_n OT, using underlying OT^k_m protocol and
// PRG: {0, 1}^m -> {0, 1}^n.
extern bool ServerPrgOTExtension(ServerPrgOTExtensionParams* params);
// Perform PRG OT-Extension as Client.
extern bool ClientPrgOTExtension(ClientPrgOTExtensionParams* params);

// Perform IKNP OT-Extension as Server: OT^k_m -> OT^m_l.
// On Input, params->black_box_ot_params_ must have protocol_ set.
// The steps are as follows (see Figure 1 of IKNP OT Extension paper):
//   0) Input: Server has m secrets of length l; in params.secrets_
//   1) Server generates k random selection bits 's'
//   2) Server acts as Client, running underlying OT^k_m (K times), to get "Q"
//   3) Server sends Client {(y^j_0, y^j_1)}_j, for j \in [1..2 * |C|]
extern bool ServerIKNPOTExtension(ServerIKNPOTExtensionParams* params);
// Perform IKNP OT-Extension as Client: OT^k_m -> OT^m_l.
// On Input, params->black_box_ot_params_ must have protocol_ set.
// The steps are as follows (see Figure 1 of IKNP OT Extension paper):
//   0) Input: Client has |C| selection bits; randomly generated, in
//      params.selection_bits_and_output_secret_.b_
//   1) Client generates a random (m, k)-Matrix M
//   2) Client acts as Server, running underlying OT
extern bool ClientIKNPOTExtension(ClientIKNPOTExtensionParams* params);

// Perform OT^k_m as Server, according to the specifications of 'params'.
// In particular, will evaluate the params->protocol_ field, and call the
// corresponding OT function, using the appropriately casted 'params' as input.
extern bool ServerOT(ServerOTParams* params);
// Perform 1-2 OT as Client, according to the specifications of 'params'.
// In particular, will evaluate the params->protocol_ field, and call the
// corresponding OT function, using the appropriately casted 'params' as input.
extern bool ClientOT(ClientOTParams* params);

}  // namespace crypto

#endif
